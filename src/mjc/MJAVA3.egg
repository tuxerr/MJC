-- PROJET3 STL 11-12 - micro java : grammaire 
option auto= true;
option version = 0.0.0 ;
option k=3;

-- les attributs semantiques
inh source : MJAVASourceFile for PROGRAMME;
syn type : DTYPE for TYPE, PARF, AFFX, E, ER, ERX, ES, T, ESX, F, TX, Q;
syn ltype : ARGLIST for PARFS, ARGS;
inh iltype : ARGLIST for PARF, PARFSX, ARGSX;
inh rltype : ARGLIST for MCORPS, BLOC, INSTS, INST, SIX;
syn acctypes : ACCEPTEDTYPES for OPREL, OPADD, OPMUL, OPUN;
inh pointedclass : CLASSE for AFFX, ER, ES, T, F, ERX, ESX, TX;
inh returntype : DTYPE for MCORPS, INST, INSTS, BLOC, SIX;
inh machine : ABSTRACTMACHINE for ENTITES, DEFCLASSE, DEFINTERFACE, MCORPS, CORPS, DEFS, DEF, BLOC, INSTS, INST, SIX, E, ER, ERX, ES, ESX, T, TX, F, OPADD, OPMUL, OPUN, OPREL, Q, AFFX, ARGS, ARGSX;
syn code : STRING for ENTITES, DEFCLASSE, DEFINTERFACE, CORPS, MCORPS, DEFS, DEF, BLOC, INSTS, INST, SIX, AFFX, E, ER, ERX, ES, ESX, T, TX, F, OPADD, OPMUL, OPUN, OPREL, Q, ARGS, ARGSX;
inh tds : TDS for ENTITES, DEFCLASSE, DEFINTERFACE, CORPS, DEF, DEFS, MCORPS, BLOC, TYPE, PARF, PARFSX, PARFS, INSTS, INST, SIX, F, T, TX, E, ER, ERX, ES, ESX, AFFX, ARGS, ARGSX, Q;
inh varisright : BOOLEAN for AFFX, ER, ES, T, F, ERX, ESX, TX, Q;
inh tdsinit : TDS for Q;
inh eiser : BOOLEAN for AFFX, ER, ES, T, F, ERX, ESX, TX, Q, E;
inh qident : STRING for Q;
inh qtype : DTYPE for Q;
inh qisvar : BOOLEAN for Q;
inh qclasse : CLASSE for Q;
syn est_affectable : BOOLEAN for E, ER, ERX, ES, ESX, T, TX, F, Q;
syn adr : INTEGER for INST, INSTS;
inh hadr : INTEGER for INST, INSTS, BLOC, SIX;
syn ext : STRING for ETEND, SUPER;
syn imp : STRING for IMPL, SUPER;
inh dep : INTEGER for ARGS, ARGSX, PARFSX;
syn name : STRING for PARF;
inh class : CLASSE for CORPS, DEFS, DEF, MCORPS, BLOC, TYPE, PARF, PARFSX, PARFS, INSTS, INST, SIX, F, T, TX, E, ER, ERX, ES, ESX, AFFX, ARGS, ARGSX, Q;
inh classname : STRING for CORPS, DEFS, DEF;
syn mainclass : CLASSE for ENTITES, DEFCLASSE, DEF, DEFS, CORPS;

-- les terminaux 
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar cro is  "\["; 
sugar crf is  "\]";
sugar virg is  ",";
sugar pv is  "\;";
sugar pt is  "\.";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar int is  "int";
sugar bool is  "boolean";
sugar classe is  "class";
sugar interface is  "interface";
sugar etend is  "extends";
sugar implemente is  "implements";
sugar retour is  "return";
sugar nouveau is  "new";
sugar null is  "null";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
sugar vrai is  "true";
sugar faux is  "false";
term entier is  "[0-9]+";
term ident is  "[_A-Za-z][_0-9A-Za-z]*";

---------- REGLES DE PRODUCTION ----------------------------------------
PROGRAMME -> #init ENTITES #gen;
global
   machine : ABSTRACTMACHINE;
   
#init {
 do
   machine := PROGRAMME^source.getMachine();
   ENTITES^machine := machine;
   ENTITES^tds := PROGRAMME^source.getTDS();
 end
}

#gen {
 do
   if ENTITES^mainclass = nil then
     error(B_32);
   else
     call machine.writeCode(PROGRAMME^source.getFileName(), 
        machine.genMalloc(ENTITES^mainclass.getTaille()) + 
        machine.genVTables(ENTITES^mainclass,ENTITES^mainclass) + 
        machine.genDeb() + 
        machine.genFin() + 
        ENTITES^code);     
   end

 end
}

ENTITES -> #gen;
#gen {
 do
   ENTITES^code := "";
   ENTITES^mainclass := nil;
 end
}

ENTITES -> DEFCLASSE ENTITES #gen;
#gen {
 do
   ENTITES^code := DEFCLASSE^code + ENTITES1^code;
   if ENTITES1^mainclass /= nil then
     if DEFCLASSE^mainclass /= nil then
       error(B_31);
     else 
       ENTITES^mainclass:=ENTITES1^mainclass;
     end
   else
     ENTITES^mainclass := DEFCLASSE^mainclass;
   end
 end
}

ENTITES -> DEFINTERFACE ENTITES #gen;
#gen {
 do
   ENTITES^code := DEFINTERFACE^code + ENTITES1^code;
   ENTITES^mainclass := ENTITES1^mainclass;
 end
}
-------------------------------------------------------
-- definition d'une classe
-------------------------------------------------------
DEFCLASSE -> classe ident SUPER #gen CORPS #checkandinsert;
global
  c : CLASSE;

#gen {
 local
   i : CLASSE;
   r : CLASSE;
 do
   c := DEFCLASSE^tds.chercherLocalementClasse(ident^txt);
   CORPS^tds := c.getTDS();
   CORPS^class := c;
   CORPS^classname := ident^txt;
 end
}

#checkandinsert {
 local
  r : CLASSE;
 do

  if SUPER^imp.equals("") then
     --pas d'implémentation d'interfaces
  else
       -- impl d'interface
       r := DEFCLASSE^tds.chercherGlobalementClasse(SUPER^imp);
       if r /= nil then

         --l'identifiant est trouvé dans la TDS
           if ~c.implementsCorrectly(r) then
             error(B_11,ident^txt,SUPER^imp,c.implementGetError());
           else 
             call c.addSuperClass(r);
           end

       else
         error(B_13,SUPER^ext); 
       end
  end

  DEFCLASSE^code := DEFCLASSE^machine.genClasse(ident^txt) + CORPS^code;
  DEFCLASSE^mainclass := CORPS^mainclass;
 end
}


DEFINTERFACE -> interface ident SUPER #gen CORPS #insert;
global
  c : CLASSE;

#gen {
 do
   c := DEFINTERFACE^tds.chercherLocalementClasse(ident^txt);
   CORPS^tds := c.getTDS();
   CORPS^class := c;
   CORPS^classname := ident^txt;
 end
}

#insert {
 local
 do
   DEFINTERFACE^code := DEFINTERFACE^machine.genComment("decl d'interface " + ident^txt);
 end
}

-------------------------------------------------------
-- 1 extends maximum suivi d'un implements maximum
-------------------------------------------------------
SUPER -> ETEND IMPL #gen;
#gen {
 do
   SUPER^ext := ETEND^ext;
   SUPER^imp := IMPL^imp;
 end
}

ETEND -> #gen;
#gen {
 do
   ETEND^ext := "";
 end
}

ETEND -> etend ident #gen;
#gen {
 do
   ETEND^ext := ident^txt;
 end
}

IMPL -> #gen;
#gen {
 do
   IMPL^imp := "";
 end
}

IMPL -> implemente ident #gen;
#gen {
 do
   IMPL^imp := ident^txt;
 end
}

CORPS -> aco DEFS acf #gen;
#gen {
 do
   CORPS^code := DEFS^code;
   CORPS^mainclass := DEFS^mainclass;
 end
}

-------------------------------------------------------
-- les attributs
-------------------------------------------------------
DEFS -> #gen;
#gen {
 do
   DEFS^code := "";
   DEFS^mainclass := nil;
 end
}

DEFS -> DEF DEFS #gen;
#gen {
 do
   if DEFS1^mainclass /= nil then
     if DEF^mainclass /= nil then
       error(B_30);
     else 
       DEFS^mainclass:=DEFS1^mainclass;
     end
   else
     DEFS^mainclass := DEF^mainclass;
   end
   DEFS^code := DEF^code + DEFS1^code;
 end
}

-------------------------------------------------------
-- attribut
-------------------------------------------------------
DEF -> TYPE ident pv  #inf;
#inf {
 local
   i : VAR;
 do
    i := DEF^tds.chercherLocalementVar(ident^txt);
    DEF^code := DEF^machine.genDeclAtt(ident^txt, i);
    DEF^mainclass := nil;
 end
}

-------------------------------------------------------
-- methode (fonction) 
-------------------------------------------------------
DEF -> TYPE ident paro #tds PARFS parf #transret #inf MCORPS #gen;
 global
   m : METHODE;
#tds {
 local
  t : TDS;
 do
   t := new TDS(DEF^tds);
   PARFS^tds := t;
   MCORPS^tds := t;
   MCORPS^returntype := TYPE^type;
 end
}

#transret {
 do
   MCORPS^rltype := PARFS^ltype;
 end
}

#inf {
 do
    m := DEF^tds.chercherLocalementMethod(ident^txt,PARFS^ltype);
 end
}
#gen {
 do
   if ident^txt.equals("main") then
     DEF^mainclass := DEF^class;
   else
     DEF^mainclass := nil;
   end
   DEF^code := DEF^machine.genDeclMet(ident^txt,m) + MCORPS^code;
 end
}
-------------------------------------------------------
-- methode (procedure)
-------------------------------------------------------
DEF -> void ident paro #tds PARFS parf #transret #inf MCORPS #gen;
 global
   m : METHODE;
#tds {
 local
   t : TDS;
 do
   t := new TDS(DEF^tds);
   MCORPS^tds := t;
   MCORPS^returntype := new DTYPE("void",0);
   PARFS^tds := t;
 end
}
#transret {
 do
   MCORPS^rltype := PARFS^ltype;
 end
}
#inf {
 local
 do
   m := DEF^tds.chercherLocalementMethod(ident^txt,PARFS^ltype);
 end
}
#gen {
 do
   if ident^txt.equals("main") then
     DEF^mainclass := DEF^class;
   else
     DEF^mainclass := nil;
   end
   DEF^code := DEF^machine.genDeclMet(ident^txt,m) + MCORPS^code + DEF^machine.genReturn("", PARFS^ltype, new DTYPE("void", 0));
 end
}
-------------------------------------------------------
-- dans classe ou dans interface
-------------------------------------------------------
MCORPS -> #check pv #gen;
#check {
  local
  do
    if MCORPS^class.isAClass() then
      error(B_17);
    end
  end
}

#gen {
  local
  do
    MCORPS^code := "";
  end
}

MCORPS -> #check BLOC #gen;
#check {
  local
  do
    if ~MCORPS^class.isAClass() then
      error(B_18);
    end
    BLOC^hadr := 3;
  end
}

#gen {
  local
  do
    MCORPS^code := BLOC^code;
  end
}

-------------------------------------------------------
-- constructeur
-------------------------------------------------------
DEF -> ident paro #tds PARFS parf #transtds BLOC #inf ; 
#tds {
 local
   t : TDS;
 do
   t := new TDS(DEF^tds);
   PARFS^tds := t;
   BLOC^tds := t;
 end
}

#transtds {
  local
  do
    BLOC^rltype := PARFS^ltype;
    BLOC^hadr := 3;
    BLOC^returntype := new DTYPE("void", 0);
  end
}

#inf {
 local
   m : METHODE;
   t : DTYPE;
 do
   m := DEF^tds.chercherLocalementMethod(ident^txt,PARFS^ltype);
   DEF^code := DEF^machine.genDeclCons(ident^txt, m) + BLOC^code + DEF^machine.genReturn("", PARFS^ltype, new DTYPE("void", 0));
   DEF^mainclass := nil;
 end
}

-------------------------------------------------------
-- les types
-------------------------------------------------------
TYPE -> int #type;
#type {
 do
   TYPE^type := new DTYPE("entier", 1);
 end
}

TYPE -> bool #type;
#type {
 do
   TYPE^type := new DTYPE("booleen", 1);
 end
}

TYPE -> ident #type;
#type {
 local
   i : CLASSE ;
   p : POINTEUR;
 do
   -- rechercher l'ident   
   i := TYPE^tds.chercherGlobalementClasse(ident^txt);
   if i = nil then
     error(B_03, ident^txt);
   else
     p := new POINTEUR(i);
     TYPE^type := p;
   end
 end
}

-------------------------------------------------------
-- parametres de methodes
-------------------------------------------------------
-- ne rien faire !
PARFS -> #ltypes;
#ltypes {
  do
    PARFS^ltype := new ARGLIST();
  end
}

PARFS -> #ltypes PARF #tds PARFSX ;
#ltypes {
  local
    a : ARGLIST;
  do
    a := new ARGLIST();
    PARFS^ltype := a;
    PARF^iltype := a;
    PARFSX^iltype := a;
  end
}

#tds {
 local
   i : VAR;
   d : INTEGER;
   dm : INTEGER;
 do
   d := PARF^type.getTaille() + 1;
   dm := 0-d;
   i := new VAR(PARF^type, dm, "LB", false);
   call PARFS^tds.inserer(PARF^name, i);
   PARFSX^dep := d;
 end
}

--ne rien faire !
PARFSX -> ;


PARFSX -> virg  PARF #tds PARFSX ;
#tds {
 local
   i : VAR;
   d : INTEGER;
   dm : INTEGER;
 do
   d := PARF^type.getTaille() + PARFSX^dep;
   dm := 0-d;
   i := new VAR(PARF^type, dm, "LB", false);
   call PARFSX^tds.inserer(PARF^name, i);
   PARFSX1^dep := d;
 end
}


PARF -> TYPE ident #tds #ltypes;
#tds {
 do
   PARF^type := TYPE^type;
   PARF^name := ident^txt;
 end
}

#ltypes {
do
   call PARF^iltype.add(TYPE^type);
end
}

-------------------------------------------------------
-- corps de methode et bloc d'instructions
-------------------------------------------------------
BLOC -> aco #tds INSTS acf #gen;
#tds {
  local
  do
    INSTS^tds := new TDS(BLOC^tds);
  end
}

#gen {
 do
   --libérer les variables locales
   BLOC^code := INSTS^code + BLOC^machine.genFree(INSTS^adr - BLOC^hadr);
 end
}

-------------------------------------------------------
-- instructions
-------------------------------------------------------
INSTS -> #gen;
#gen {
 do
   INSTS^adr := INSTS^hadr;
   INSTS^code := "";
 end
}

INSTS ->INST #adr INSTS #gen;
#adr {
 do
   INSTS1^hadr := INST^adr;
 end
}
#gen {
 do
   INSTS^adr := INSTS1^adr;
   INSTS^code := INST^code + INSTS1^code;
 end
}

-------------------------------------------------------
-- declaration de variable locale avec ou sans init
-------------------------------------------------------
INST-> TYPE ident #affxtype AFFX pv #gen;
#affxtype {
  local
  do
    match TYPE^type 
    with CLASSE then
      AFFX^pointedclass := TYPE^type;
    else
      AFFX^pointedclass := nil;
    end
    AFFX^varisright := true;
    AFFX^eiser := true;
  end          
}

#gen {
 local
   v : VAR;
   vn : VAR;
 do
   v := INST^tds.chercherGlobalementVar(ident^txt);
   if v /= nil then
     error(B_02, ident^txt);
   elseif ~TYPE^type.canAccept(AFFX^type) then
     error(B_00, TYPE^type, AFFX^type);
   else
     vn := new VAR(TYPE^type, INST^hadr, "LB", false);
     call INST^tds.inserer(ident^txt, vn);
     INST^adr := INST^hadr + TYPE^type.getTaille();
     INST^code := INST^machine.genVarLoc(ident^txt, vn, AFFX^code);
   end
 end
}

-------------------------------------------------------
-- instruction expression
-------------------------------------------------------
INST -> #eiser E pv #gen;
#eiser {
 do
   E^eiser := false;
 end
}

#gen {
 do
   INST^adr := INST^hadr;
   INST^code := E^code;
 end
}

-------------------------------------------------------
-- bloc d'instructions
-------------------------------------------------------
INST -> BLOC #gen;
#gen {
 do
   INST^adr := INST^hadr;
   INST^code := BLOC^code;
 end
}

-------------------------------------------------------
-- conditionnelle
-------------------------------------------------------
-- possibilite de declarations : modifier adr, hadr
INST -> si paro #eiser E #type parf BLOC SIX #gen;
#eiser {
 do
   E^eiser := true;
 end
}

#type {
do
 if ~E^type.equals(new DTYPE("booleen", 1)) then
   error(B_05, E^type);
 end
end
}

#gen {
 do
   INST^adr := INST^hadr;
   INST^code := INST^machine.genIf(E^code, BLOC^code, SIX^code);
 end
}

SIX -> sinon BLOC #gen;
#gen {
 do
   SIX^code := BLOC^code;
 end
}

SIX -> #gen;
#gen {
 do
   SIX^code := "";
 end
}

-------------------------------------------------------
-- return
-------------------------------------------------------
--AFAIRE
INST -> retour #ergen E pv #gen;
#ergen {
 do
   E^eiser := true;
 end
}

#gen {
 do
   if ~E^type.equals(INST^returntype) then
     error(B_23,INST^returntype.toString(),E^type.toString());
   end
   INST^adr := INST^hadr;
   INST^code := INST^machine.genReturn(E^code, INST^rltype, INST^returntype);
 end
}

-------------------------------------------------------
-- les expressions
-------------------------------------------------------
E -> #ertype ER #affxtype AFFX #gen;
#ertype {
  do
    if E^eiser then
      ER^varisright := true;
    else
      ER^varisright := false;
    end
    ER^pointedclass := nil;
    AFFX^varisright := true;
    AFFX^eiser := false;
  end
}

#affxtype {
  local
  do
    match ER^type 
    with CLASSE then
      AFFX^pointedclass := ER^type;
    else
      AFFX^pointedclass := nil;
    end
  end          
}

#gen {
 do
   if ER^est_affectable then
     if AFFX^type.equals(new DTYPE("void", 0)) then
       E^est_affectable := true;
       E^type := ER^type;
       E^code := ER^code;
     else
       if ~ER^type.canAccept(AFFX^type) then
         error(B_00, ER^type, AFFX^type);
       else
         E^est_affectable := false;
         E^type := new DTYPE("void", 0);
         E^code := AFFX^code + ER^code;
       end
     end
   else
     if ~AFFX^type.equals(new DTYPE("void", 0)) then
       error(B_10);
     else
       E^est_affectable := false;
       E^type := ER^type;
       E^code := ER^code;
     end
   end
 end
}


-------------------------------------------------------
-- affectation
-------------------------------------------------------
AFFX -> affect ER #gen;
#gen {
 do
   AFFX^type := ER^type;
   if ER^est_affectable then
     AFFX^code := ER^code;
   else
     AFFX^code := ER^code;
   end
 end
}

AFFX -> #gen;
#gen {
 do
   AFFX^type := new DTYPE("void", 0);
   AFFX^code := "";
 end
}

-------------------------------------------------------
-- relation
-------------------------------------------------------
ER -> ES ERX #gen;
#gen {
 do
   if ~ERX^type.equals(new DTYPE("void", 0))&~ERX^type.equals(ES^type) then
     error(B_00, ES^type, ERX^type);
   elseif ~ERX^est_affectable then
     --ERX contient une OPREL
     ER^est_affectable := false;
     ER^type := new DTYPE("booleen",1);
     ER^code := ES^code + ERX^code;
   else
     --ERX est vide
     ER^est_affectable := ES^est_affectable;
     ER^type := ES^type;
     ER^code := ES^code + ERX^code;
   end
 end
}

ES -> T ESX #gen;
#gen {
 do
   if ~ESX^type.equals(new DTYPE("void", 0))&~ESX^type.equals(T^type) then
     error(B_00, ESX^type, T^type);
   elseif ~ESX^est_affectable then
     ES^est_affectable := false;
     ES^code := T^code + ESX^code;
   else
     ES^est_affectable := T^est_affectable;
     ES^code := T^code + ESX^code;
   end
   ES^type := T^type;
 end
}

ERX -> OPREL ES #gen;
#gen {
 do
   if ~OPREL^acctypes.contains(ES^type) then
     error(B_00, ES^type, OPREL^acctypes.toString());
   end
   ERX^est_affectable := false;
   ERX^type := ES^type;
   ERX^code := ES^code + OPREL^code;
 end
}

ERX -> #gen;
#gen {
 do
   ERX^est_affectable := true;
   ERX^type := new DTYPE("void", 0);
   ERX^code := "";
 end
}

OPREL -> inf #gen;
#gen {
 local
   a : ACCEPTEDTYPES;
 do
   OPREL^code := OPREL^machine.genOpLss();
   a := new ACCEPTEDTYPES();
   call a.add(new DTYPE("entier",1));
   OPREL^acctypes := a;
 end
}

OPREL -> infeg #gen;
#gen {
 local
   a : ACCEPTEDTYPES;
 do
   OPREL^code := OPREL^machine.genOpLeq();
   a := new ACCEPTEDTYPES();
   call a.add(new DTYPE("entier",1));
   OPREL^acctypes := a;
 end
}

OPREL -> sup #gen;
#gen {
 local
   a : ACCEPTEDTYPES;
 do

 OPREL^code := OPREL^machine.genOpGtr();
   a := new ACCEPTEDTYPES();
   call a.add(new DTYPE("entier",1));
   OPREL^acctypes := a;
 end
}

OPREL -> supeg #gen;
#gen {
 local
   a : ACCEPTEDTYPES;
 do
   OPREL^code := OPREL^machine.genOpGeq();
   a := new ACCEPTEDTYPES();
   call a.add(new DTYPE("entier",1));
   OPREL^acctypes := a;
 end
}

OPREL -> eg #gen;
#gen {
 local
   a : ACCEPTEDTYPES;
 do
   OPREL^code := OPREL^machine.genOpEq();
   a := new ACCEPTEDTYPES();
   call a.add(new DTYPE("entier",1));
   call a.add(new DTYPE("booleen",1));
   call a.add(new DTYPE("pointeur",1));
   OPREL^acctypes := a;
 end
}

OPREL -> neg #gen;
#gen {
 local
   a : ACCEPTEDTYPES;
 do
   OPREL^code := OPREL^machine.genOpNeq();
   a := new ACCEPTEDTYPES();
   call a.add(new DTYPE("entier",1));
   call a.add(new DTYPE("booleen",1));
   call a.add(new DTYPE("pointeur",1));
   OPREL^acctypes := a;
 end
}

-------------------------------------------------------
-- addition, ...
-------------------------------------------------------
ESX -> OPADD T ESX #gen;
#gen {
 do
   if ~OPADD^acctypes.contains(T^type) then
     error(B_00, T^type, OPADD^acctypes);
   elseif ~ESX1^type.equals(new DTYPE("void", 0))&~T^type.equals(ESX1^type) then
     error(B_00, T^type, ESX1^type);
   else
     ESX^est_affectable := false;
     ESX^type := T^type;
     ESX^code := T^code + ESX1^code + OPADD^code;
   end
 end
}

ESX -> #gen;
#gen {
 do
   ESX^est_affectable := true;
   ESX^type := new DTYPE("void", 0);
   ESX^code := "";
 end
}

OPADD -> plus #gen;
#gen {
 local
   a : ACCEPTEDTYPES;
 do
   OPADD^code := OPADD^machine.genOpAdd();
   a := new ACCEPTEDTYPES();
   call a.add(new DTYPE("entier",1));
   OPADD^acctypes := a;
 end
}

OPADD -> moins #gen;
#gen {
 local
   a : ACCEPTEDTYPES;
 do
   OPADD^code := OPADD^machine.genOpSub();
   a := new ACCEPTEDTYPES();
   call a.add(new DTYPE("entier",1));
   OPADD^acctypes := a;
 end
}

OPADD -> ou #gen;
#gen {
 local
   a : ACCEPTEDTYPES;
 do
   OPADD^code := OPADD^machine.genOpOr();
   a := new ACCEPTEDTYPES();
   call a.add(new DTYPE("entier",1));
   OPADD^acctypes := a;
 end
}

T -> F TX #gen;
#gen {
 do
   if ~TX^type.equals(new DTYPE("void", 0))&~F^type.equals(TX^type) then
     error(B_00, F^type, TX^type);
   else
     if ~TX^est_affectable then
       T^est_affectable := false;
       T^code := F^code + TX^code;
     else
       T^est_affectable := F^est_affectable;
       T^code := F^code + TX^code;
     end
     T^type := F^type;
   end
 end
}

-------------------------------------------------------
-- multiplication, ...
-------------------------------------------------------
TX -> OPMUL F TX #gen;
#gen {
 do
   if ~OPMUL^acctypes.contains(F^type) then
     error(B_00, F^type, OPMUL^acctypes);
   elseif ~TX1^type.equals(new DTYPE("void", 0))&~F^type.equals(TX1^type) then
     error(B_00, F^type, TX1^type);
   else
     TX^est_affectable := false;
     TX^type := F^type;
     TX^code := F^code + TX1^code + OPMUL^code;
   end
 end
}

TX -> #gen;
#gen {
 do
   TX^est_affectable := true;
   TX^type := new DTYPE("void", 0);
   TX^code := "";
 end
}

OPMUL -> mult #gen;
#gen {
 local
   a : ACCEPTEDTYPES;
 do
   a := new ACCEPTEDTYPES();
   call a.add(new DTYPE("entier",1));
   OPMUL^acctypes := a;
   OPMUL^code := OPMUL^machine.genOpMul();
 end
}

OPMUL -> div #gen;
#gen {
 local
   a : ACCEPTEDTYPES;
 do
   a := new ACCEPTEDTYPES();
   call a.add(new DTYPE("entier",1));
   OPMUL^acctypes := a;
   OPMUL^code := OPMUL^machine.genOpDiv();
 end
}

OPMUL -> mod #gen;
#gen {
 local
   a : ACCEPTEDTYPES;
 do
   a := new ACCEPTEDTYPES();
   call a.add(new DTYPE("entier",1));
   OPMUL^acctypes := a;
   OPMUL^code := OPMUL^machine.genOpMod();
 end
}

OPMUL -> et #gen;
#gen {
 local
   a : ACCEPTEDTYPES;
 do
   a := new ACCEPTEDTYPES();
   call a.add(new DTYPE("entier",1));
   OPMUL^acctypes := a;
   OPMUL^code := OPMUL^machine.genOpAnd();
 end
}

-------------------------------------------------------
-- expressions de base
-------------------------------------------------------
F -> entier #gen;
#gen {
 do
   F^est_affectable := false;
   F^type := new DTYPE("entier", 1);
   F^code := F^machine.genCst(entier^txt);
 end
}

F -> vrai #gen;
#gen {
 do
   F^est_affectable := false;
   F^type := new DTYPE("booleen", 1);
   F^code := F^machine.genCst("1");
 end
}

F -> faux #gen;
#gen {
 do
   F^est_affectable := false;
   F^type := new DTYPE("booleen", 1);
   F^code := F^machine.genCst("0");
 end
}

-------------------------------------------------------
-- unaire
-------------------------------------------------------
F -> OPUN F #gen;
#gen {
 do
   if ~OPUN^acctypes.contains(F1^type) then
     error(B_00, F1^type, OPUN^acctypes);
   else
     F^est_affectable := false;
     F^type := F1^type;
     F^code := F1^code + OPUN^code;
   end
 end
}

OPUN -> plus #gen;
#gen {
 local
   a : ACCEPTEDTYPES;
 do
   a := new ACCEPTEDTYPES();
   OPUN^acctypes := a;
   call a.add(new DTYPE("entier",1));
   OPUN^code := OPUN^machine.genOpAdd();
 end
}

OPUN -> moins #gen;
#gen {
 local
   a : ACCEPTEDTYPES;
 do
   a := new ACCEPTEDTYPES();
   OPUN^acctypes := a;
   call a.add(new DTYPE("entier",1));
   OPUN^code := OPUN^machine.genOpSub();
 end
}

OPUN -> non #gen;
#gen {
 local
   a : ACCEPTEDTYPES;
 do
   a := new ACCEPTEDTYPES();
   OPUN^acctypes := a;
   call a.add(new DTYPE("entier",1));
   OPUN^code := OPUN^machine.genOpNeg();
 end
}

-------------------------------------------------------
-- null
-------------------------------------------------------
--AFAIRE
F -> null #gen;
#gen {
 do
   F^est_affectable := false;
   F^type := new POINTEUR(nil);
   F^code := F^machine.genCst("0");
 end
}

F -> paro #eiser E parf #gen;
#eiser {
 do
   E^eiser := F^eiser;
 end
}

#gen {
 do
   F^est_affectable := E^est_affectable;
   F^type := E^type;
   F^code := E^code;
 end
}

-------------------------------------------------------
-- new
-------------------------------------------------------
-- AFAIRE
F -> nouveau #init TYPE paro ARGS parf #gen;
#init {
  do
    ARGS^dep := 0;
  end
}
#gen {
 local
   c : CLASSE;
   cname : STRING;
   met : METHODE;
   ctds : TDS;
   mn : INTEGER;
 do
   match TYPE^type
     with POINTEUR then
       c := TYPE^type.getPointedType();
       cname := c.getNom();
       ctds := c.getTDS();
       met := ctds.chercherGlobalementMethod(cname,ARGS^ltype);
       if met /= nil then
          mn := c.getMethodNumber(cname, ARGS^ltype);
          F^type := TYPE^type;
          if F^pointedclass /= nil then
            F^code := F^machine.genMalloc(c.getTaille()) + F^machine.genVTables(F^pointedclass,c) + ARGS^code + F^machine.genGetMallocPointer(ARGS^ltype.getTaille()) + F^machine.genCall(mn, "constructeur");
          else
            F^code := F^machine.genMalloc(c.getTaille()) + F^machine.genVTables(c,c) + ARGS^code + F^machine.genGetMallocPointer(ARGS^ltype.getTaille()) + F^machine.genCall(mn, "constructeur");
          end
       else
          error(B_28,cname,ARGS^ltype);
          F^code :="";
       end
       
     else
       error(B_19);
   end
    
   F^est_affectable := false;  
 end
}

F -> ident #tra Q #gen;
#tra {
 local
 do 
   Q^qident := ident^txt;   
   Q^qisvar := true;
   Q^qtype := nil;
   Q^tdsinit := F^tds;
   Q^qclasse := new CLASSE(false, new TDS(), "");
 end
}
#gen {
 do
   F^est_affectable := Q^est_affectable;
   F^type := Q^type;
   F^code := Q^code;
 end
}

-------------------------------------------------------
-- Q = qualificateur de variable
-------------------------------------------------------
Q -> #gen;
#gen {
 local 
   v : VAR;
   name : STRING;
 do 
   if Q^qisvar then
     v := Q^tds.chercherGlobalementVar(Q^qident);
     if v /= nil then
       Q^type := v.getType();
       Q^est_affectable := true;
       if v.isAttr() then
         name := Q^qclasse.getNom();
         if name.equals("") then
           --si l'attribut est un attribut de la classe actuelle
           if Q^varisright then
             Q^code := Q^machine.genCurrentClassPointer() + Q^machine.genAtt(Q^qident, v) + Q^machine.genReadMemRAM(v.getTaille());
           else
             Q^code := Q^machine.genCurrentClassPointer() + Q^machine.genAtt(Q^qident, v) + Q^machine.genWriteMemRAM(v.getTaille());
           end
         else
           -- attribut d'une autre classe (p.m)
           if Q^varisright then
             Q^code := Q^machine.genAtt(Q^qident, v) + Q^machine.genReadMemRAM(v.getTaille());
           else
             Q^code := Q^machine.genAtt(Q^qident, v) + Q^machine.genWriteMemRAM(v.getTaille());
           end
         end
       else
         if Q^varisright then
           Q^code := Q^machine.genVar(v.getDep(), v.getTaille(), v.getReg());
         else
           Q^code := Q^machine.genWriteMemStack(v);
         end
         
       end
     else
       error(B_33, Q^qident);
     end
   else
     Q^type := Q^qtype;
     Q^est_affectable := false;
     Q^code := "";
   end
 end
}

-------------------------------------------------------
-- acces attribut ou méthode
-------------------------------------------------------
Q -> pt ident #tra Q #gen;
global
   v : VAR;

#tra {
 local
   vt : DTYPE;
   c : CLASSE;
   
 do
   if Q^qisvar then
     v := Q^tds.chercherGlobalementVar(Q^qident);
     if v /= nil then
       vt := v.getType();
       match vt
       with POINTEUR then
         c := vt.getPointedType();
         Q1^tds := c.getTDS();
         Q1^qident := ident^txt;
         Q1^qisvar := true;
         Q1^qclasse := c;

       else  
         error(B_21, Q^qident);
       end
     else
       error(B_07,ident^txt);    
     end
   else
     match Q^qtype
     with POINTEUR then
       c := Q^qtype.getPointedType();
       Q1^tds := c.getTDS();
       Q1^qident := ident^txt;
       Q1^qisvar := true;
       Q1^qclasse := c;
     else
       error(B_29);
     end
   end
 end
}

#gen {
 do
   Q^est_affectable := Q1^est_affectable;
   Q^type := Q1^type;
   if Q^qisvar then
      Q^code := Q^machine.genVar(v.getDep(),v.getTaille(),v.getReg()) + Q1^code;
   else
      Q^code := Q1^code;
   end
 end
}

-------------------------------------------------------
-- arguments d'appel de methode
-------------------------------------------------------
Q -> paro #init ARGS #check parf Q #gen;
global
 m : METHODE;
#init {
 do
  ARGS^tds := Q^tdsinit;
  ARGS^dep := 0;
 end
}
#check {
 local
   t : DTYPE;
 do
   m := Q^tds.chercherGlobalementMethod(Q^qident,ARGS^ltype);
   if m /= nil then
     t := m.getReturnType();
     Q1^qtype:=t;
     Q1^qisvar:=false;
   else 
     error(B_28,Q^qident,ARGS^ltype);
   end
 end
}
#gen {
 local
   mn : INTEGER;
   name : STRING;
 do
   name := Q^qclasse.getNom();
   if name.equals("") then
     mn := Q^class.getMethodNumber(Q^qident, ARGS^ltype);
     Q^est_affectable := Q1^est_affectable;
     Q^type := Q1^type;
     Q^code := ARGS^code + Q^machine.genCurrentClassPointer() + Q^machine.genCall(mn, Q^qident) + Q1^code;
   else
     mn := Q^qclasse.getMethodNumber(Q^qident, ARGS^ltype);
     Q^est_affectable := Q1^est_affectable;
     Q^type := Q1^type;
     Q^code := ARGS^code + Q^machine.genPopArgs(ARGS^ltype.getTaille()) + Q^machine.genCall(mn, Q^qident) + Q1^code;
   end
 end
}

ARGS -> #eiser E #ltypes ARGSX #gen;
#eiser {
 do
  E^eiser := true;
 end
}
#ltypes {
  local
    a : ARGLIST;
  do
    a := new ARGLIST();
    ARGS^ltype := a;
    call a.add(E^type);
    ARGSX^iltype := a;
  end
}

#gen {
 do
   ARGS^code := ARGSX^code + E^code;
 end
}

ARGS -> #ltypes #gen;
#ltypes {
  do
    ARGS^ltype := new ARGLIST();
  end
}

#gen {
 do
   ARGS^code := "";
 end
}

ARGSX -> virg #eiser E #ltypes ARGSX #gen;
#eiser {
 do
  E^eiser := true;
 end
}
#ltypes {
 do
   call ARGSX^iltype.add(E^type);
 end
}
#gen {
 do
   ARGSX^code := ARGSX1^code + E^code;
 end
}

ARGSX -> #gen;
#gen {
 do
   ARGSX^code := "";
 end
}

end

-- PROJET3 STL 11-12 - micro java : grammaire 
option auto= true;
option version = 0.0.0 ;
option k=3;

-- les attributs semantiques
inh source : MJAVASourceFile for PROGRAMME;
syn type : DTYPE for TYPE, AFFX, E, ER, ERX, OPUN, ES, ESX, OPADD, T, TX, OPMUL, F, OPUN, Q;
syn code : STRING for ENTITES, DEFCLASSE, DEFINTERFACE, BLOC, INSTS, INST, AFFX, E, ER, ERX, OPUN, ES, ESX, OPADD, T, TX, OPMUL, F, OPUN, Q;
inh tds : TDS for ;
inh machine : ABSTRACTMACHINE for ;
inh hident : STRING for Q;
inh htds : TDS for Q;
syn est_adresse : BOOLEAN for E, ER, ERX, ES, ESX, T, TX, F, Q;
syn adr : INTEGER for DEF, DEFS, INST, INSTS;
inh hadr : INTEGER for DEF, DEFS, INST, INSTS, BLOC;
syn ext : BOOLEAN for ETEND, SUPER;
syn imp : BOOLEAN for IMPL, SUPER;

-- les terminaux 
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar cro is  "\["; 
sugar crf is  "\]";
sugar virg is  ",";
sugar pv is  "\;";
sugar pt is  "\.";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar int is  "int";
sugar bool is  "boolean";
sugar classe is  "class";
sugar interface is  "interface";
sugar etend is  "extends";
sugar implemente is  "implements";
sugar retour is  "return";
sugar nouveau is  "new";
sugar null is  "null";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
sugar vrai is  "true";
sugar faux is  "false";
term entier is  "[0-9]+";
term ident is  "[_A-Za-z][_0-9A-Za-z]*";

---------- REGLES DE PRODUCTION ----------------------------------------
PROGRAMME -> #init ENTITES #gen;
global
   machine : AbstractMachine;
   
#init {
 do
   machine := PROGRAMME^source.getMachine();
   ENTITES^machine := machine;
   ENTITES^tds := new TDS(nil);
end
}

#gen {
 do
   call machine.writeCode(PROGRAMME^source.getFileName(), ENTITES^code);
 end
}

ENTITES -> #gen;
#gen {
 do
   ENTITES^code := ENTITES^machine.genFin();
 end
}

ENTITES -> DEFCLASSE ENTITES #gen;
#gen {
 do
   ENTITES^code := DEFCLASSE^code + ENTITES1^code;
 end
}

ENTITES -> DEFINTERFACE ENTITES #gen;
#gen {
 do
   ENTITES^code := DEFINTERFACE^code + ENTITES1^code;
 end
}
-------------------------------------------------------
-- definition d'une classe
-------------------------------------------------------
-- AFAIRE : #verif pour les implemente
DEFCLASSE -> classe ident SUPER CORPS ;
DEFINTERFACE -> interface ident SUPER CORPS;

-------------------------------------------------------
-- 1 extends maximum suivi d'un implements maximum
-------------------------------------------------------
SUPER -> ETEND IMPL #gen;
#gen {
 do
   SUPER^ext := ETEND^ext;
   SUPER^imp := IMPL^imp;
 end
}

ETEND -> #gen;
#gen {
 do
   ETEND^ext := false;
 end
}

ETEND -> etend ident #gen;
#gen {
 do
   ETEND^ext := true;
 end
}

IMPL -> #gen;
#gen {
 do
   IMPL^imp := false;
 end
}

IMPL -> implemente ident #gen;
#gen {
 do
   IMPL^imp := true;
 end
}

CORPS -> aco DEFS acf #gen;
#gen {
 do
   CORPS^code := DEFS^code;
 end
}

-------------------------------------------------------
-- les attributs
-------------------------------------------------------
DEFS -> #gen;
#gen {
 do
   DEFS^adr := DEFS^hadr;
   DEFS^code := "";
 end
}

DEFS -> DEF #adr DEFS #gen;
#adr {
 do
   DEFS^hadr := DEF^adr;
 end
}
#gen {
 do
   DEFS^adr := DEFS1^adr;
   DEFS^code := DEF^code + DEFS1^code;
 end
}


-------------------------------------------------------
-- attribut
-------------------------------------------------------
--AFAIRE : "LB" ?
DEF -> TYPE ident pv  #inf;
#inf {
 local
   i : INFO;
   iv : INFOVAR;
   t : DTYPE;
 do
    i := DEF^tds.chercherGlobalement(ident^txt);
    if i /= nil then
       error(B_02, ident^txt);
    else
   -- ajouter l'ident dans la TDS;
    iv := new INFOVAR(TYPE^type, DEF^hadr, "LB");
    call DEF^tds.inserer(ident^txt, iv);
    DEF^adr := DEF^hadr + TYPE^type.getTaille();
    DEF^code := DEF^machine.genDeclAtt(ident^txt, iv);
 end
}

-------------------------------------------------------
-- methode (fonction) 
-------------------------------------------------------
DEF -> TYPE ident paro PARFS parf MCORPS  ;

-------------------------------------------------------
-- methode (procedure)
-------------------------------------------------------
DEF -> void ident paro PARFS parf MCORPS  ;

-------------------------------------------------------
-- dans classe ou dans interface
-------------------------------------------------------
MCORPS -> pv ;
MCORPS -> BLOC ;

-------------------------------------------------------
-- constructeur
-------------------------------------------------------
DEF -> ident paro PARFS parf BLOC  ; 

-------------------------------------------------------
-- les types
-------------------------------------------------------
TYPE -> int #type;
#type {
 do
   TYPE^type := new DTYPE("entier", 4);
 end
}

TYPE -> bool #type;
#type {
 do
   TYPE^type := new DTYPE("booleen", 1);
 end
}

TYPE -> ident #type;
#type {
 local
   i : INFO ;
   it : INFOTYPE;
   t : DTYPE;
 do
   -- rechercher l'ident   
   i := TYPE^tds.chercherGlobalement(ident^txt);
   if i = nil then
     error(B_03, ident^txt);
   else
     match i
       with INFOTYPE then
         it := i ;
         TYPE^type :=  it.getType();
       else
         error(B_04, ident^txt);
     end
   end
 end
}

-------------------------------------------------------
-- parametres de methodes
-------------------------------------------------------
PARFS -> ;
PARFS -> PARF PARFSX ;
PARFSX -> ;
PARFSX -> virg  PARF  PARFSX ;
PARF -> TYPE ident  ;

-------------------------------------------------------
-- corps de methode et bloc d'instructions
-------------------------------------------------------
BLOC -> aco #tds INSTS acf #gen;
#tds {
 do
   INSTS^tds := new TDS(BLOC^tds);
 end
}
#gen {
 do
   BLOC^code := INSTS^code + BLOC^machine.genFree(INSTS^adr - BLOC^hadr);
 end
}

-------------------------------------------------------
-- instructions
-------------------------------------------------------
INSTS -> #gen;
#gen {
 do
   INSTS^adr := INSTS^hadr;
   INSTS^code := "";
 end
}

INSTS -> INST #adr INSTS #gen;
#adr {
 do
   INSTS1^hadr := INST^adr;
 end
}
#gen {
 do
   INSTS^adr := INSTS1^adr;
   INSTS^code := INST^code + INSTS1^code;
 end
}

-------------------------------------------------------
-- declaration de variable locale avec ou sans init
-------------------------------------------------------
INST-> TYPE ident AFFX pv #gen;
#gen {
 local
   i : INFO;
   iv : INFOVAR;
 do
   i := INST^tds.chercherLocalement(ident^txt);
   if i /= nil then
     error(B_06, ident^txt);
   elseif ~AFFX^type.compareTo(new DTYPE("void", 1))&~TYPE^type.compareTo(AFFX^type) then
     error(B_00, TYPE^type, AFFX^type);
   else
     iv := new INFOVAR(TYPE^type, INST^hadr, "LB");
     call INST^tds.inserer(ident^txt, iv);
     INST^adr := INST^hadr + TYPE^type.getTaille();
     INST^code := INST^tam.genDecl(ident^txt, iv, AFFX^code);
 end
}

-------------------------------------------------------
-- instruction expression
-------------------------------------------------------
INST -> E pv #gen;
#gen {
 do
   INST^adr := INST^hadr
   INST^code := E^code;
 end
}

-------------------------------------------------------
-- bloc d'instructions
-------------------------------------------------------
INST -> BLOC #gen;
#gen {
 do
   INST^adr := INST^hadr;
   INST^code := BLOC^code;
 end
}

-------------------------------------------------------
-- conditionnelle
-------------------------------------------------------
INST -> si paro E #type parf BLOC SIX #gen;
#type {
do
 if ~E^type.compareTo(new DTYPE("booleen", 1)) then
   error(B_05, E^type);
 end
end
}
#gen {
 do
   INST^adr := INST^hadr;
   INST^code := INST^machine.genIf(E^code, BLOC^code, SIX^code);
 end
}

SIX -> sinon #adr BLOC #gen;
#adr {
 do
   BLOC^hadr := SIX^hadr;
 end
}
#gen {
 do
   SIX^code := BLOC^code;
 end
}

SIX -> #gen;
#gen {
 do
   SIX^code := "";
 end
}

-------------------------------------------------------
-- return
-------------------------------------------------------
--AFAIRE
INST -> retour E pv #gen;
#gen {
 do
   INST^adr := ????
   INST^code := INST^machine.genReturn(E^code);
 end
}

-------------------------------------------------------
-- les expressions
-------------------------------------------------------
E -> ER AFFX #gen;
#gen {
 local
   i : INFO;
 do
   if ER^est_adresse then
     if ~AFFX^type.compareTo(ER^type)) then
       error(B_00, ER^type, AFFX^type);
     elseif ~AFFX^type.compareTo(new DTYPE("void", 1)) then
       E^est_adresse := false;
       E^type := new DTYPE("void", 1);
       E^code := AFFX^code + ER^code + E^machine.genWriteMem(ER^type.getTaille());
     else
       E^est_adresse := true;
       E^type := ER^type;
       E^code := ER^code;
     end
   else
     if ~AFFX^type.compareTo(new DTYPE("void", 1)) then
       error(B_10);
     else
       E^est_adresse := false;
       E^type := ER^type;
       E^code := ER^code;
     end
   end
 end
}


-------------------------------------------------------
-- affectation
-------------------------------------------------------
AFFX -> affect ER #gen;
#gen {
 do
   AFFX^type := ER^type;
   AFFX^code := ER^code;
 end
}

AFFX -> #gen;
#gen {
 do
   AFFX^type := new DTYPE("void", 1);
   AFFX^code := "";
 end
}

-------------------------------------------------------
-- relation
-------------------------------------------------------
ER -> ES ERX #gen;
#gen {
 do
   if ~ERX^type.compareTo(new DTYPE("void", 1))&~ERX^type.compareTo(ES^type) then
     error(B_00, ES^type, ERX^type);
   elseif ~ERX^est_adresse then
     ER^est_adresse := false;
   else
     ER^est_adresse := ES^est_adresse;
   end
   ER^type := ES^type;
   ER^code := ES^code + ERX^code;
 end
}

ES -> T ESX #gen;
#gen {
 do
   if ~ESX^type.compareTo(new DTYPE("void", 1))&~ESX^type.compareTo(T^type) then
     error(B_00, ESX^type, T^type);
   elseif ~ESX^est_adresse then
     ES^est_adresse := false;
   else
     ES^est_adresse := T^est_adresse;
   end
   ES^type := T^type;
   ES^code := T^code + ESX^code;
 end
}

ERX -> OPREL ES #gen;
#gen {
 do
   ERX^est_adresse := false;
   ERX^type := new DTYPE("booleen", 1);
   ERX^code := ES^code + OPREL^code;
 end
}

ERX -> #gen;
#gen {
 do
   ERX^est_adresse := true;
   ERX^type := new DTYPE("void", 1);
   ERX^code := "";
 end
}

OPREL -> inf #gen;
#gen {
 do
   OPREL^code := OPREL^machine.genOpInf();
 end
}

OPREL -> infeg #gen;
#gen {
 do
   OPREL^code := OPREL^machine.genOpInfeg();
 end
}

OPREL -> sup #gen;
#gen {
 do
   OPREL^code := OPREL^machine.genOpSup();
 end
}

OPREL -> supeg #gen;
#gen {
 do
   OPREL^code := OPREL^machine.genSupeg();
 end
}

OPREL -> eg #gen;
#gen {
 do
   OPREL^code := OPREL^machine.genEg();
 end
}

OPREL -> neg #gen;
#gen {
 do
   OPREL^code := OPREL^machine.genNeg();
 end
}

-------------------------------------------------------
-- addition, ...
-------------------------------------------------------
ESX -> OPADD T ESX #gen;
#gen {
 do
   if ~T^type.compareTo(OPADD^type) then
     error(B_00, T^type, OPADD^type);
   elseif ~ESX1^type.compareTo(new DTYPE("void", 1))&~T^type.compareTo(ESX1^type) then
     error(B_00, T^type, ESX1^type);
   else
     ESX^est_adresse := false;
     ESX^type := T^type;
     ESX^code := T^code + ESX1^code + OPADD^code;
   end
 end
}

ESX -> #gen;
#gen {
 do
   ESX^est_adresse := true;
   ESX^type := new DTYPE("void", 1);
   ESX^code := "";
 end
}

OPADD -> plus #gen;
#gen {
 do
   OPADD^type := new DTYPE("entier", 4);
   OPADD^code := OPADD^machine.genOpAdd();
 end
}

OPADD -> moins #gen;
#gen {
 do
   OPADD^type := new DTYPE("entier", 4);
   OPADD^code := OPADD^machine.genOpMin();
 end
}

OPADD -> ou #gen;
#gen {
 do
   OPADD^type := new DTYPE("booleen", 1);
   OPADD^code := OPADD^machine.genOpOu();
 end
}

T ->  F TX #gen;
#gen {
 do
   if ~F^type.compareTo(TX^type) then
     error(B_00, F^type, TX^type);
   else
     if ~TX^est_adresse then
       T^est_adresse := false;
     else
       T^est_adresse := F^est_adresse;
     end
     T^type := TX^type;
     T^code := F^code + TX^code;
   end
 end
}

-------------------------------------------------------
-- multiplication, ...
-------------------------------------------------------
TX -> OPMUL F TX #gen;
#gen {
 do
   if ~F^type.compareTo(OPMUL^type) then
     error(B_00, F^type, OPMUL^type);
   elseif ~TX1^type.compareTo(new DTYPE("void", 1))&~F^type.compareTo(TX1^type) then
     error(B_00, F^type, TX1^type);
   else
     TX^est_adresse := false;
     TX^type := F^type;
     TX^code := F^code + TX1^code + OPMUL^code;
   end
 end
}

TX -> #gen;
#gen {
 do
   TX^est_adresse := true;
   TX^type := new DTYPE("void", 1);
   TX^code := "";
 end
}

OPMUL -> mult #gen;
#gen {
 do
   OPMUL^type := new DTYPE("entier", 4);
   OPMUL^code := OPUN^machine.genOpMul();
 end
}

OPMUL -> div #gen;
#gen {
 do
   OPMUL^type := new DTYPE("entier", 4);
   OPMUL^code := OPUN^machine.genOpDiv();
 end
}

OPMUL -> mod #gen;
#gen {
 do
   OPMUL^type := new DTYPE("entier", 4);
   OPMUL^code := OPUN^machine.genOpMod();
 end
}

OPMUL -> et #gen;
#gen {
 do
   OPMUL^type := new DTYPE("booleen", 1);
   OPMUL^code := OPUN^machine.genOpEt();
 end
}

-------------------------------------------------------
-- expressions de base
-------------------------------------------------------
F -> entier #gen;
#gen {
 do
   F^est_adresse := false;
   F^type := new DTYPE("entier", 4);
   F^code := F^machine.genCst(entier^txt);
 end
}

F -> vrai #gen;
#gen {
 do
   F^est_adresse := false;
   F^type := new DTYPE("booleen", 1);
   F^code := F^machine.genCst("1");
 end
}

F -> faux #gen;
#gen {
 do
   F^est_adresse := false;
   F^type := new DTYPE("booleen", 1);
   F^code := F^machine.genCst("0");
 end
}

-------------------------------------------------------
-- unaire
-------------------------------------------------------
F -> OPUN F #gen;
#gen {
 do
   if ~F1^type.compareTo(OPUN^type) then
     error(B_00, F1^type, OPUN^type);
   else
     F^est_adresse := false;
     F^type := F1^type;
     F^code := F1^code + OPUN^code;
   end
 end
}

OPUN -> plus #gen;
#gen {
 do
   OPUN^type := new DTYPE("entier", 4);
   OPUN^code := OPUN^machine.genOpPlus();
 end
}

OPUN -> moins #gen;
#gen {
 do
   OPUN^type := new DTYPE("entier", 4);
   OPUN^code := OPUN^machine.genOpMoins();
 end
}

OPUN -> non #gen;
#gen {
 do
   OPUN^type := new DTYPE("booleen", 1);
   OPUN^code := OPUN^machine.genOpNon();
 end
}

-------------------------------------------------------
-- null
-------------------------------------------------------
--AFAIRE
F -> null #gen;
#gen {
 do
   F^est_adresse := false;
   F^type := new DTYPE("null", 1);
   F^code := "";
 end
}

F -> paro E parf #gen;
#gen {
 do
   F^est_adresse := E^est_adresse;
   F^type := E^type;
   F^code := E^code;
 end
}

-------------------------------------------------------
-- new
-------------------------------------------------------
-- définir l'erreur d'arguments sur TYPE : AFAIRE
F -> nouveau TYPE paro ARGS parf #gen;
#gen {
 do
   if then
     error(B_01, TYPE^type)
   else
     F^type := TYPE^type;
   end
 end
}

F -> ident #tra Q #gen;
#tra {
 do
   Q^hident := ident^txt;
   Q^htds := F^tds;
 end
}
#gen {
 do

   F^est_adresse := Q^est_adresse;
   F^type := Q^type;
   F^code := Q^code;
 end
}

-------------------------------------------------------
-- Q = qualificateur de variable
-------------------------------------------------------
Q -> #gen;
#gen{
 local 
   iv : INFOVAR ;
   t : DTYPE;
   i : INFO;
 do
   i := Q^htds.chercherGlobalement(Q^hident);
   if i = nil then
     error(B_07, ident^txt);
   end
   match i
   with INFOVAR then
     iv := i;
     t := iv.getType();
     Q^type := t;
     Q^est_adresse := true;
     Q^code :=Q^machine.genAdr(iv.getDep(), iv.getReg());
   else
     error(B_08, ident^txt);
   end
 end
}

-------------------------------------------------------
-- acces attribut ou méthode
-------------------------------------------------------
Q -> pt ident Q ;

-------------------------------------------------------
-- arguments d'appel de methode
-------------------------------------------------------
Q -> paro ARGS parf Q ;

ARGS ->  E ARGSX  ;
ARGS -> ;
ARGSX ->   virg E ARGSX  ;
ARGSX -> ;

end

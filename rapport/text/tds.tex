//Inclusion du graphe.png qui servira de support aux explications
La TDS que nous avons choisie est une variation de celle qui nous a été donnée en TP de TDL. En effet, au lieu d'hériter d'une HashMap<String,INFO>, elle 
contient en tant qu'attributs 3 HashMaps de variables, méthodes et classes respectivement, comme il est visible sur le graphe UML. Le principe même d'une
HashMap est d'être une bijection entre 
la clef de type String et la Valeur de type INFO, et sachant que notre projet devait gérer le fait qu'une variable peut avoir le même nom qu'une méthode, 
ou qu'une classe doit avoir le même nom que son constructeur, une seule HashMap n'était pas possible. Nos fonctions chercherGlobalement sont donc triples, 
une pour les variables, une pour les classes et une pour les méthodes.
Sachant que nous gérons aussi la surcharge de méthode, la fonction chercherGlobalementMethod prend aussi en argument les arguments que la fonction doit 
matcher pour être considérée comme acceptable. La HashMap de méthodes est en effet, pour des soucis d'optimisation, une HashMap de LMETHODES, une classe 
contenant une liste de méthodes ayant le même nom (ayant donc des arguments différents, sachant qu'on ne peut surcharger le type de retour). La fonction 
chercherGlobalementMethode(nom,arguments) trouve donc d'abord dans la HashMap de la TDS la liste de méthodes ayant ce nom, puis trouve dans cette liste 
une méthode matchant les arguments. 
Ce système nous permet donc d'avoir des constructeurs surchargés du même nom (logiquement) que la classe, et même un attribut de cette classe ayant le même 
nom que sa classe.

Nous avons en outre conservé le système de DTYPE, dont notre type POINTEUR est une classe fille (POINTEUR contient aussi le DTYPE pointé).

Un des problèmes que nous avons rencontré est celui du typage de Micro-Java créé par la distinction entre type réel et type apparent. En effet, il est possible
pour un exemple contenant une classe P ayant comme classe fille PC d'avoir une définition
 
  P p = new PC();

Or, dans cet exemple, PC à pour type ``Pointeur pointant vers PC'' et P a pour type ``Pointeur pointant vers P'', mais l'affectation est tout a fait valide. Nous avons donc
développé une fonction canAccept pour les DTYPE permettant de savoir si, même si les types ne sont pas égaux, l'affectation est valide (par exemple, dans le cas du pointeur null
étant accepté par tous pointeurs). En effet, pour chaque classe, nous avons défini une liste générée lors de la 2ème passe de notre compilateur de classes acceptables
comme Super-Classes lors d'une affectation. Cette fonction est par exemple utilisée dans ARGLIST (classe gérant les listes d'arguments pour les paramètres de fonctions) pour autoriser
le passage d'un PC en tant qu'argument dont le type était P.

Pour la génération des vtables, la classe METHODE contenant les informations des méthodes contient de façon évidente l'étiquette de chacune des méthodes, positionnée au début du code de cette méthode, 
pour pouvoir générer pour chaque méthode son entrée vtable, ainsi que le numéro de la méthode en question. En effet, chaque méthode de classe est numérotée de 0 à nb\_methode-1, ce qui permet 
pour l'appel des méthodes de savoir dans quelle position elle est dans la vtable (voir partie liaison tardive et gestion des interfaces).


